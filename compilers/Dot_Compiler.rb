module Dot_Compiler
  extend self

  #-----------------------------------------------
  # Predicates to DOT
  #-----------------------------------------------

  def predicates_to_dot(output, group, group_not)
    group.each {|p| output << "(#{p.join(' ')})\\l"}
    group_not.each {|p| output << "not (#{p.join(' ')})\\l"}
  end

  #-----------------------------------------------
  # Compile domain
  #-----------------------------------------------

  def compile_domain(domain_name, problem_name, operators, methods, predicates, state, tasks, goal_pos, goal_not)
    domain_str = "// Generated by Hype\ndigraph g {\n  nodesep=1.0;\n  ranksep=1.0;\n"
    # Operators
    operators.each {|op|
      # Header
      domain_str << "  #{op.first} [\n    shape=record\n    label=\"{{#{op.first}|#{op[1].join(' ')}}|{"
      # Preconditions
      predicates_to_dot(domain_str, op[2], op[3])
      # Effects
      domain_str << '|'
      predicates_to_dot(domain_str, op[4], op[5])
      domain_str << "}}\"\n  ];\n"
    }
    # Methods
    methods.each {|met|
      decompose = met.drop(2)
      domain_str << "  #{met.first} [\n    shape=Mrecord\n    style=bold\n    label=\"{{#{met.first}|#{met[1].join(' ')}}|{#{decompose.each_with_index.map {|d,i| "<n#{i}>#{d.first}"}.join('|')}}}\"];\n"
      decompose.each_with_index {|d,i|
        # Label
        domain_str << "  #{d.first} [\n    shape=Mrecord\n    label=\"{{#{d.first}|#{d[1].join(' ')}}|"
        # Preconditions
        predicates_to_dot(domain_str, d[2], d[3])
        # Subtasks
        d[4].each_with_index {|subtask,j| domain_str << "|<n#{j}>#{subtask.join(' ')}"}
        # Connections
        domain_str << "}\"\n  ];\n  #{met.first}:n#{i} -> #{d.first};\n"
        d[4].each_with_index {|subtask,j| domain_str << "  #{d.first}:n#{j} -> #{subtask.first};\n" if operators.any? {|op| op.first == subtask.first}}
      }
    }
    domain_str << '}'
  end

  #-----------------------------------------------
  # Compile problem
  #-----------------------------------------------

  def compile_problem(domain_name, problem_name, operators, methods, predicates, state, tasks, goal_pos, goal_not, domain_filename)
    # TODO graphs for simple relationship between objects (extremely cluttered), maybe only the tasks
  end
end