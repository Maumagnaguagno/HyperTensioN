module Dot_Compiler
  extend self

  #-----------------------------------------------
  # Compile Domain
  #-----------------------------------------------

  def compile_domain(domain_name, operators, methods, predicates, state, tasks, goal_pos, goal_not)
    domain_str = "// Generated by Hype\ndigraph g {\n"
    # Operators
    operators.each {|op|
      # Header
      domain_str << "  #{op.first} [\n    shape=record\n    label=\"{{#{op.first}|#{op[1].map {|i| "?#{i}"}.join(' ')}}|{"
      # Preconditions
      op[2].each {|p| domain_str << "(#{p.first}#{p.drop(1).map {|i| " ?#{i}"}.join})\\n"}
      op[3].each {|p| domain_str << "not (#{p.first}#{p.drop(1).map {|i| " ?#{i}"}.join})\\n"}
      # Effects
      domain_str << '|'
      op[4].each {|p| domain_str << "(#{p.first}#{p.drop(1).map {|i| " ?#{i}"}.join})\\n"}
      op[5].each {|p| domain_str << "not (#{p.first}#{p.drop(1).map {|i| " ?#{i}"}.join})\\n"}
      domain_str << "}}\"\n  ];\n"
    }
    # Methods
    methods.each {|met|
      domain_str << "  #{met.first} [\n    shape=record\n    label=\"{{#{met.first}|#{met[1].map {|i| "?#{i}"}.join(' ')}}|{#{met.drop(2).each_with_index.map {|decompose,i| "<n#{i}>#{decompose.first}"}.join('|')}}}\"];\n"
      met.drop(2).each_with_index {|met_decompose,i|
        # Label
        domain_str << "  #{met_decompose.first} [\n    shape=record\n    label=\"{{#{met_decompose.first}|#{met_decompose[1].map {|t| "?#{t}"}.join(' ')}}|"
        # Preconditions
        met_decompose[2].each {|p| domain_str << "(#{p.first}#{p.map {|t| " ?#{t}"}.join})\\n"}
        met_decompose[3].each {|p| domain_str << "not (#{p.first}#{p.map {|t| " ?#{t}"}.join})\\n"}
        domain_str << '|{' << met_decompose[4].each_with_index.map {|subtask,j| "<n#{j}>#{subtask.first}#{subtask.drop(1).map {|s| " ?#{s}"}.join}"}.join('|') << "}}\"\n  ];\n"
        # Subtasks
        domain_str << "  #{met.first}:n#{i} -> #{met_decompose.first};\n"
        met_decompose[4].each_with_index {|subtask,j| domain_str << "  #{met_decompose.first}:n#{j} -> #{subtask.first};\n" if operators.any? {|op| op.first == subtask.first}}
      }
    }
    domain_str << '}'
  end

  #-----------------------------------------------
  # Compile Problem
  #-----------------------------------------------

  def compile_problem(domain_name, operators, methods, predicates, state, tasks, goal_pos, goal_not, domain_filename)
    # TODO
    problem_str = ''
  end
end