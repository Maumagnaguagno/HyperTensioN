module JSHOP_Compiler
  extend self

  def propositions_to_jshop(output, group, group_not = [])
    if group.empty? and group_not.empty?
      output << "    nil\n"
    else
      output << "    (\n"
      group.each {|pre| output << "      (#{pre.first} #{pre.drop(1).map {|i| "?#{i}"}.join(' ')})\n"}
      group_not.each {|pre| output << "      (not (#{pre.first} #{pre.drop(1).map {|i| "?#{i}"}.join(' ')}))\n"}
      output << "    )\n"
    end
  end

  def compile_domain(domain_name, operators, methods, predicates, state, tasks)
    domain_str = "; Generated by Hype\n"
    domain_str << "(defdomain #{domain_name}(\n\n"
    # Operators
    domain_str << '  ;' << '=' * 30 << "\n  ; Operators\n  ;" << '=' * 30 << "\n\n"
    operators.each {|op|
      # Header
      domain_str << "  (:operator (!#{op.first} #{op[1].map {|i| "?#{i}"}.join(' ')})\n"
      # Preconditions
      propositions_to_jshop(domain_str, op[2], op[3])
      # Delete effects
      propositions_to_jshop(domain_str, op[5])
      # Add effects
      propositions_to_jshop(domain_str, op[4])
      domain_str << "  )\n\n"
    }
    # Methods
    domain_str << '  ;' << '=' * 30 << "\n  ; Methods\n  ;" << '=' * 30 << "\n\n"
    methods.each {|met|
      header = "  (:method (#{met.first}#{met[1].map {|i| " ?#{i}"}.join})\n"
      met.drop(2).each {|met_decompose|
        # Header and label
        domain_str << header << "    #{met_decompose.first}\n"
        # Preconditions
        propositions_to_jshop(domain_str, met_decompose[2], met_decompose[3])
        # Subtasks
        propositions_to_jshop(domain_str, met_decompose[4])
        domain_str << "  )\n\n"
      }
    }
    domain_str << '))'
  end

  def compile_problem(domain_name, operators, methods, predicates, state, tasks, domain_filename)
    # Start
    problem_str = "(defproblem problem #{domain_name}\n\n  ;" << '=' * 30 << "\n  ; Start\n  ;" << '=' * 30 << "\n\n  (\n"
    state.each {|pre| problem_str << "    (#{pre.first} #{pre.drop(1).join(' ')})\n"}
    # Tasks
    problem_str << "  )\n\n  ;" << '=' * 30 << "\n  ; Tasks\n  ;" << '=' * 30 << "\n\n  (\n"
    tasks.each {|pre| problem_str << "    (#{pre.first} #{pre.drop(1).join(' ')})\n"}
    problem_str << "  )\n)\n"
  end
end