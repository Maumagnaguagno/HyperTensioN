module PDDL_Compiler
  extend self

  #-----------------------------------------------
  # Propositions to PDDL
  #-----------------------------------------------

  def propositions_to_pddl(output, group = [], group_not = [], indentation = '    ')
    unless group.empty? and group_not.empty?
      group.each {|pre| output << "#{indentation}(#{pre.first} #{pre.drop(1).map {|i| "?#{i}"}.join(' ')})\n"}
      group_not.each {|pre| output << "#{indentation}(not (#{pre.first} #{pre.drop(1).map {|i| "?#{i}"}.join(' ')}))\n"}
    end
  end

  #-----------------------------------------------
  # Compile Domain
  #-----------------------------------------------

  def compile_domain(domain_name, operators, methods, predicates, state, tasks)
    # TODO support goal state
    domain_str = "; Generated by Hype\n(define (domain #{domain_name})\n"
    # TODO negative-preconditions are not required for some domains
    domain_str << "  (:requirements :strips :negative-preconditions)\n\n"
    # Predicates
    # TODO add initial and goal state predicates
    domain_str << "  (:predicates\n"
    predicates = {}
    operators.each {|op| 2.upto(5) {|i| op[i].each {|p| predicates[p.first] = p unless predicates.include?(p.first)}}}
    propositions_to_pddl(domain_str, predicates.values)
    domain_str << "  )\n"
    # Operators
    operators.each {|op|
      # Header
      domain_str << "\n  (:action #{op.first}\n    :parameters (#{op[1].map {|i| "?#{i}"}.join(' ')})\n"
      # Preconditions
      domain_str << "    :precondition\n      (and\n"
      propositions_to_pddl(domain_str, op[2], op[3], '        ')
      domain_str << "      )\n"
      # Effects
      domain_str << "    :effect\n      (and\n"
      propositions_to_pddl(domain_str, op[4], op[5], '        ')
      domain_str << "      )\n  )\n"
    }
    domain_str << ')'
  end

  #-----------------------------------------------
  # Compile Problem
  #-----------------------------------------------

  def compile_problem(domain_name, operators, methods, predicates, state, tasks, domain_filename)
    # TODO obtain problem name
    # TODO support goal state
    problem_str = "(define (problem pb0)\n  (:domain #{domain_name})\n"
    # TODO negative-preconditions are not required for some domains
    problem_str << "  (:requirements :strips :negative-preconditions)\n"
    # Objects
    problem_str << "  (:objects\n"
    # TODO extract objects from initial and goal state and list them here
    # Initial state
    problem_str << "  )\n  (:init\n"
    # TODO initial propositions
    # Goal state
    problem_str << "  )\n  (:goal\n    (and\n"
    # TODO goal propositions
    problem_str << "    )\n  )\n)"
  end
end