require './tests/hypest'

class Dependent < Test::Unit::TestCase
  include Hypest

  def test_dependency_pb1_pddl_parsing
    parser_tests(
      # Files
      'examples/dependency/dependency.pddl',
      'examples/dependency/pb1.pddl',
      # Parser and extensions
      PDDL_Parser, [],
      # Attributes
      :domain_name => 'dependency',
      :problem_name => 'pb1',
      :operators => [
        ['work', ['?a'],
          # Preconditions
          [['agent', '?a']],
          [['got_money', '?a']],
          # Effects
          [['got_money', '?a']],
          [['happy', '?a']]
        ],
        ['buy', ['?a', '?x'],
          # Preconditions
          [['agent', '?a'], ['object', '?x'], ['got_money', '?a']],
          [['have', '?a', '?x']],
          # Effects
          [['have', '?a', '?x']],
          [['got_money', '?a']]
        ],
        ['give', ['?a', '?b', '?x'],
          # Preconditions
          [['agent', '?a'], ['agent', '?b'], ['object', '?x'], ['have', '?a', '?x']],
          [['have', '?b', '?x']],
          # Effects
          [['have', '?b', '?x'], ['happy', '?b']],
          [['have', '?a', '?x']]
        ]
      ],
      :methods => [],
      :predicates => {
        'agent' => false,
        'object' => false,
        'have' => true,
        'got_money' => true,
        'happy' => true
      },
      :state => {
        'agent' => [['ana'], ['bob']],
        'object' => [['gift']],
        'have' => [['ana', 'gift']]
      },
      :tasks => [],
      :goal_pos => [['happy', 'bob']],
      :goal_not => [],
      :objects => ['ana', 'bob', 'gift'],
      :requirements => [':strips', ':typing', ':negative-preconditions']
    )
  end

  def test_dependency_pb1_pddl_parsing_with_patterns_compile_to_jshop
    compiler_tests(
      # Files
      'examples/dependency/dependency.pddl',
      'examples/dependency/pb1.pddl',
      # Parser, extensions and output
      PDDL_Parser, ['patterns'], 'jshop',
      # Domain
      DEPENDENCY_DOMAIN_JSHOP + UNIFY_BUY_GIVE,
      # Problem
      DEPENDENCY_PROBLEM_JSHOP.sub('<pb>','1').sub!('<start>', "\n    (have ana gift)").sub!('<tasks>', '(unify_a_x_before_dependency_buy_before_give_for_happy bob)')
    )
  end

  def test_dependency_pb2_pddl_parsing_with_patterns_compile_to_jshop
    compiler_tests(
      # Files
      'examples/dependency/dependency.pddl',
      'examples/dependency/pb2.pddl',
      # Parser, extensions and output
      PDDL_Parser, ['patterns'], 'jshop',
      # Domain
      DEPENDENCY_DOMAIN_JSHOP + UNIFY_BUY_GIVE,
      # Problem
      DEPENDENCY_PROBLEM_JSHOP.sub('<pb>','2').sub!('<start>', '').sub!('<tasks>', '(unify_a_x_before_dependency_buy_before_give_for_happy bob)')
    )
  end

  def test_dependency_pb3_pddl_parsing_with_patterns_compile_to_jshop
    compiler_tests(
      # Files
      'examples/dependency/dependency.pddl',
      'examples/dependency/pb3.pddl',
      # Parser, extensions and output
      PDDL_Parser, ['patterns'], 'jshop',
      # Domain
      DEPENDENCY_DOMAIN_JSHOP + '))',
      # Problem
      DEPENDENCY_PROBLEM_JSHOP.sub('<pb>','3').sub!('<start>', '').sub!('<tasks>', '(!work bob)')
    )
  end

  def test_dependency_pb4_pddl_parsing_with_patterns_compile_to_jshop
    compiler_tests(
      # Files
      'examples/dependency/dependency.pddl',
      'examples/dependency/pb4.pddl',
      # Parser, extensions and output
      PDDL_Parser, ['patterns'], 'jshop',
      # Domain
      DEPENDENCY_DOMAIN_JSHOP + '))',
      # Problem
      DEPENDENCY_PROBLEM_JSHOP.sub('<pb>','4').sub!('<start>', '').sub!('<tasks>', '(dependency_work_before_buy_for_have bob gift)')
    )
  end

  def test_dependency_pb5_pddl_parsing_with_patterns_compile_to_jshop
    compiler_tests(
      # Files
      'examples/dependency/dependency.pddl',
      'examples/dependency/pb5.pddl',
      # Parser, extensions and output
      PDDL_Parser, ['patterns'], 'jshop',
      # Domain
      DEPENDENCY_DOMAIN_JSHOP + UNIFY_BUY_GIVE,
      # Problem
      DEPENDENCY_PROBLEM_JSHOP.sub('<pb>','5').sub!('<start>', "\n    (happy bob)").sub!('<tasks>', '(unify_a_x_before_dependency_buy_before_give_for_happy bob)')
    )
  end

  def test_dependency_pb1_pddl_parsing_with_patterns_compile_to_rb
    compiler_tests(
      # Files
      'examples/dependency/dependency.pddl',
      'examples/dependency/pb1.pddl',
      # Parser, extensions and output
      PDDL_Parser, ['patterns'], 'rb',
      # Domain
      DEPENDENCY_DOMAIN_RB,
      # Problem
      DEPENDENCY_PROBLEM_RB
    )
  end

  DEPENDENCY_DOMAIN_JSHOP = '; Generated by Hype
(defdomain dependency (

  ;------------------------------
  ; Operators
  ;------------------------------

  (:operator (!work ?a)
    (
      (agent ?a)
      (not (got_money ?a))
    )
    (
      (happy ?a)
    )
    (
      (got_money ?a)
    )
  )

  (:operator (!buy ?a ?x)
    (
      (agent ?a)
      (object ?x)
      (got_money ?a)
      (not (have ?a ?x))
    )
    (
      (got_money ?a)
    )
    (
      (have ?a ?x)
    )
  )

  (:operator (!give ?a ?b ?x)
    (
      (agent ?a)
      (agent ?b)
      (object ?x)
      (have ?a ?x)
      (not (have ?b ?x))
    )
    (
      (have ?a ?x)
    )
    (
      (have ?b ?x)
      (happy ?b)
    )
  )

  ;------------------------------
  ; Methods
  ;------------------------------

  (:method (dependency_work_before_buy_for_have ?a ?x)
    goal-satisfied
    (
      (have ?a ?x)
    )
    ()
  )

  (:method (dependency_work_before_buy_for_have ?a ?x)
    satisfied
    (
      (agent ?a)
      (object ?x)
      (got_money ?a)
    )
    (
      (!buy ?a ?x)
    )
  )

  (:method (dependency_work_before_buy_for_have ?a ?x)
    unsatisfied
    (
      (agent ?a)
      (object ?x)
      (not (got_money ?a))
    )
    (
      (!work ?a)
      (!buy ?a ?x)
    )
  )

  (:method (dependency_buy_before_give_for_have ?a ?x ?b)
    goal-satisfied
    (
      (have ?b ?x)
    )
    ()
  )

  (:method (dependency_buy_before_give_for_have ?a ?x ?b)
    satisfied
    (
      (agent ?a)
      (agent ?b)
      (object ?x)
      (have ?a ?x)
    )
    (
      (!give ?a ?b ?x)
    )
  )

  (:method (dependency_buy_before_give_for_have ?a ?x ?b)
    unsatisfied
    (
      (agent ?a)
      (agent ?b)
      (object ?x)
      (not (have ?a ?x))
    )
    (
      (dependency_work_before_buy_for_have ?a ?x)
      (!give ?a ?b ?x)
    )
  )

  (:method (dependency_buy_before_give_for_happy ?a ?x ?b)
    goal-satisfied
    (
      (happy ?b)
    )
    ()
  )

  (:method (dependency_buy_before_give_for_happy ?a ?x ?b)
    satisfied
    (
      (agent ?a)
      (agent ?b)
      (object ?x)
      (have ?a ?x)
    )
    (
      (!give ?a ?b ?x)
    )
  )

  (:method (dependency_buy_before_give_for_happy ?a ?x ?b)
    unsatisfied
    (
      (agent ?a)
      (agent ?b)
      (object ?x)
      (not (have ?a ?x))
    )
    (
      (dependency_work_before_buy_for_have ?a ?x)
      (!give ?a ?b ?x)
    )
  )
'

UNIFY_BUY_GIVE = '
  (:method (unify_a_x_before_dependency_buy_before_give_for_happy ?b)
    a_x
    (
      (agent ?a)
      (agent ?b)
      (object ?x)
    )
    (
      (dependency_buy_before_give_for_happy ?a ?x ?b)
    )
  )
))'

DEPENDENCY_PROBLEM_JSHOP = '; Generated by Hype
(defproblem pb<pb> dependency

  ;------------------------------
  ; Start
  ;------------------------------

  (
    (agent ana)
    (agent bob)
    (object gift)<start>
  )

  ;------------------------------
  ; Tasks
  ;------------------------------

  (:unordered
    <tasks>
  )
)'

DEPENDENCY_DOMAIN_RB = "# Generated by Hype
require '#{File.expand_path('../../Hypertension', __FILE__)}'

module Dependency
  include Hypertension
  extend self

  #-----------------------------------------------
  # Domain
  #-----------------------------------------------

  @domain = {
    # Operators
    :work => true,
    :buy => true,
    :give => true,
    # Methods
    :dependency_work_before_buy_for_have => [
      :dependency_work_before_buy_for_have_goal_satisfied,
      :dependency_work_before_buy_for_have_satisfied,
      :dependency_work_before_buy_for_have_unsatisfied
    ],
    :dependency_buy_before_give_for_have => [
      :dependency_buy_before_give_for_have_goal_satisfied,
      :dependency_buy_before_give_for_have_satisfied,
      :dependency_buy_before_give_for_have_unsatisfied
    ],
    :dependency_buy_before_give_for_happy => [
      :dependency_buy_before_give_for_happy_goal_satisfied,
      :dependency_buy_before_give_for_happy_satisfied,
      :dependency_buy_before_give_for_happy_unsatisfied
    ],
    :unify_a_x_before_dependency_buy_before_give_for_happy => [
      :unify_a_x_before_dependency_buy_before_give_for_happy_a_x
    ]
  }

  #-----------------------------------------------
  # Operators
  #-----------------------------------------------

  def work(_a)
    return unless AGENT.include?(_a)
    return if @state[GOT_MONEY].include?(_a)
    @state = @state.dup
    (@state[HAPPY] = @state[HAPPY].dup).delete(_a)
    (@state[GOT_MONEY] = @state[GOT_MONEY].dup).unshift(_a)
    true
  end

  def buy(_a, _x)
    return unless AGENT.include?(_a)
    return unless OBJECT.include?(_x)
    return unless @state[GOT_MONEY].include?(_a)
    return if @state[HAVE].include?([_a, _x])
    @state = @state.dup
    (@state[GOT_MONEY] = @state[GOT_MONEY].dup).delete(_a)
    (@state[HAVE] = @state[HAVE].dup).unshift([_a, _x])
    true
  end

  def give(_a, _b, _x)
    return unless AGENT.include?(_a)
    return unless AGENT.include?(_b)
    return unless OBJECT.include?(_x)
    return unless @state[HAVE].include?([_a, _x])
    return if @state[HAVE].include?([_b, _x])
    @state = @state.dup
    (@state[HAVE] = @state[HAVE].dup).delete([_a, _x])
    @state[HAVE].unshift([_b, _x])
    (@state[HAPPY] = @state[HAPPY].dup).unshift(_b)
    true
  end

  #-----------------------------------------------
  # Methods
  #-----------------------------------------------

  def dependency_work_before_buy_for_have_goal_satisfied(_a, _x)
    return unless @state[HAVE].include?([_a, _x])
    yield []
  end

  def dependency_work_before_buy_for_have_satisfied(_a, _x)
    return unless AGENT.include?(_a)
    return unless OBJECT.include?(_x)
    return unless @state[GOT_MONEY].include?(_a)
    yield [
      [:buy, _a, _x]
    ]
  end

  def dependency_work_before_buy_for_have_unsatisfied(_a, _x)
    return unless AGENT.include?(_a)
    return unless OBJECT.include?(_x)
    return if @state[GOT_MONEY].include?(_a)
    yield [
      [:work, _a],
      [:buy, _a, _x]
    ]
  end

  def dependency_buy_before_give_for_have_goal_satisfied(_a, _x, _b)
    return unless @state[HAVE].include?([_b, _x])
    yield []
  end

  def dependency_buy_before_give_for_have_satisfied(_a, _x, _b)
    return unless @state[HAVE].include?([_a, _x])
    return unless AGENT.include?(_a)
    return unless AGENT.include?(_b)
    return unless OBJECT.include?(_x)
    yield [
      [:give, _a, _b, _x]
    ]
  end

  def dependency_buy_before_give_for_have_unsatisfied(_a, _x, _b)
    return unless AGENT.include?(_a)
    return unless AGENT.include?(_b)
    return unless OBJECT.include?(_x)
    return if @state[HAVE].include?([_a, _x])
    yield [
      [:dependency_work_before_buy_for_have, _a, _x],
      [:give, _a, _b, _x]
    ]
  end

  def dependency_buy_before_give_for_happy_goal_satisfied(_a, _x, _b)
    return unless @state[HAPPY].include?(_b)
    yield []
  end

  def dependency_buy_before_give_for_happy_satisfied(_a, _x, _b)
    return unless @state[HAVE].include?([_a, _x])
    return unless AGENT.include?(_a)
    return unless AGENT.include?(_b)
    return unless OBJECT.include?(_x)
    yield [
      [:give, _a, _b, _x]
    ]
  end

  def dependency_buy_before_give_for_happy_unsatisfied(_a, _x, _b)
    return unless AGENT.include?(_a)
    return unless AGENT.include?(_b)
    return unless OBJECT.include?(_x)
    return if @state[HAVE].include?([_a, _x])
    yield [
      [:dependency_work_before_buy_for_have, _a, _x],
      [:give, _a, _b, _x]
    ]
  end

  def unify_a_x_before_dependency_buy_before_give_for_happy_a_x(_b)
    return unless AGENT.include?(_b)
    AGENT.each {|_a|
      OBJECT.each {|_x|
        yield [
          [:dependency_buy_before_give_for_happy, _a, _x, _b]
        ]
      }
    }
  end
end"

DEPENDENCY_PROBLEM_RB = "# Generated by Hype
require_relative 'dependency.pddl'

# Predicates
AGENT = [
  :ana,
  :bob
]
GOT_MONEY = 0
HAPPY = 1
OBJECT = [
  :gift
]
HAVE = 2

Dependency.problem(
  # Start
  [
    [],
    [],
    [
      [:ana, :gift]
    ],
  ],
  # Tasks
  [
    [:unify_a_x_before_dependency_buy_before_give_for_happy, :bob]
  ],
  # Debug
  ARGV.first == 'debug'
) {
  # Goal
  Dependency.state[HAPPY].include?(:bob)
}"
end