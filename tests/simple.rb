require './tests/hypest'

class Simple < Test::Unit::TestCase
  include Hypest

  OPERATORS = [
    ['pickup', ['?a'],
      # Preconditions
      [],
      [['have', '?a']],
      # Effects
      [['have', '?a']],
      []
    ],
    ['drop', ['?a'],
      # Preconditions
      [['have', '?a']],
      [],
      # Effects
      [],
      [['have', '?a']]
    ]
  ]

  def basic_pb1_htn_parsing(parser, extension, method1_label, method2_label)
    parser_tests(
      # Files
      "examples/basic/basic.#{extension}",
      "examples/basic/pb1.#{extension}",
      # Parser and extensions
      parser, [],
      # Attributes
      :domain_name => 'basic',
      :problem_name => 'pb1',
      :operators => OPERATORS,
      :methods => [
        ['swap', ['?x', '?y'],
          [method1_label, [],
            # Preconditions
            [['have', '?x']],
            [['have', '?y']],
            # Subtasks
            [['drop', '?x'], ['pickup', '?y']]
          ],
          [method2_label, [],
            # Preconditions
            [['have', '?y']],
            [['have', '?x']],
            # Subtasks
            [['drop', '?y'], ['pickup', '?x']]
          ]
        ]
      ],
      :predicates => {'have' => true},
      :state => {'have' => [['kiwi']]},
      :tasks => [true, ['swap', 'banjo', 'kiwi']],
      :goal_pos => [],
      :goal_not => []
    )
  end

  def test_basic_pb1_hddl_parsing
    basic_pb1_htn_parsing(HDDL_Parser, 'hddl', 'have_first', 'have_second')
  end

  def test_basic_pb1_jshop_parsing
    basic_pb1_htn_parsing(JSHOP_Parser, 'jshop', 'case_0', 'case_1')
  end

  def test_basic_pb1_pddl_parsing
    parser_tests(
      # Files
      'examples/basic/basic.pddl',
      'examples/basic/pb1.pddl',
      # Parser and extensions
      PDDL_Parser, [],
      # Attributes
      :domain_name => 'basic',
      :problem_name => 'pb1',
      :operators => OPERATORS,
      :methods => [],
      :predicates => {'have' => true},
      :state => {},
      :tasks => [],
      :goal_pos => [['have', 'banjo']],
      :goal_not => [],
      :objects => ['kiwi', 'banjo'],
      :requirements => [':strips', ':negative-preconditions']
    )
  end

  def test_basic_pb1_jshop_parsing_compile_to_pddl
    compiler_tests(
      # Files
      'examples/basic/basic.jshop',
      'examples/basic/pb1.jshop',
      # Extensions and output
      [], 'pddl',
      # Domain
'; Generated by Hype
(define (domain basic)
  (:requirements :strips :negative-preconditions)

  (:predicates
    (have ?a)
  )

  (:action pickup
    :parameters (?a)
    :precondition (and
      (not (have ?a))
    )
    :effect (and
      (have ?a)
    )
  )

  (:action drop
    :parameters (?a)
    :precondition (and
      (have ?a)
    )
    :effect (and
      (not (have ?a))
    )
  )
)',
      # Problem
'; Generated by Hype
(define (problem pb1)
  (:domain basic)
  (:objects
    kiwi banjo
  )
  (:init
    (have kiwi)
  )
  (:goal (and
  ))
)'
    )
  end

  def test_basic_pb1_pddl_parsing_with_patterns
    parser_tests(
      # Files
      'examples/basic/basic.pddl',
      'examples/basic/pb3.pddl',
      # Parser and extensions
      PDDL_Parser, ['patterns'],
      # Attributes
      :domain_name => 'basic',
      :problem_name => 'pb3',
      :operators => OPERATORS,
      :methods => [],
      :predicates => {'have' => true},
      :state => {'have' => [['kiwi']]},
      :tasks => [false, ['pickup', 'banjo'], ['drop', 'kiwi']],
      :goal_pos => [['have', 'banjo']],
      :goal_not => [['have', 'kiwi']],
      :objects => ['kiwi', 'banjo'],
      :requirements => [':strips', ':negative-preconditions']
    )
  end

  def test_basic_pb1_jshop_parsing_with_macro
    parser_tests(
      # Files
      'examples/basic/basic.jshop',
      'examples/basic/pb1.jshop',
      # Parser and extensions
      JSHOP_Parser, ['macro'],
      # Attributes
      :domain_name => 'basic',
      :problem_name => 'pb1',
      :operators => [
        ['pickup', ['?a'], [], [], [], []],
        ['drop', ['?a'], [], [], [], []],
        ['invisible_macro_drop_and_pickup', ['?x', '?y'],
          # Preconditions
          [['have', '?x']],
          [['have', '?y']],
          # Effects
          [['have', '?y']],
          [['have', '?x']]
        ]
      ],
      :methods => [
        ['swap', ['?x', '?y'],
          ['case_0', [],
            # Preconditions
            [['have', '?x']],
            [['have', '?y']],
            # Subtasks
            [['invisible_macro_drop_and_pickup', '?x', '?y'], ['drop', '?x'], ['pickup', '?y']]
          ],
          ['case_1', [],
            # Preconditions
            [['have', '?y']],
            [['have', '?x']],
            # Subtasks
            [['invisible_macro_drop_and_pickup', '?y', '?x'], ['drop', '?y'], ['pickup', '?x']]
          ]
        ]
      ],
      :predicates => {'have' => true},
      :state => {'have' => [['kiwi']]},
      :tasks => [true, ['swap', 'banjo', 'kiwi']],
      :goal_pos => [],
      :goal_not => []
    )
  end

  def test_basic_pb1_pddl_parsing_with_dummy_compile_to_jshop
    compiler_tests(
      # Files
      'examples/basic/basic.pddl',
      'examples/basic/pb1.pddl',
      # Extensions and output
      ['dummy'], 'jshop',
      # Domain
"; Generated by Hype
(defdomain basic (

  ;------------------------------
  ; Operators
  ;------------------------------

  (:operator (!pickup ?a)
    (
      (not (have ?a))
    )
    ()
    (
      (have ?a)
    )
  )

  (:operator (!drop ?a)
    (
      (have ?a)
    )
    (
      (have ?a)
    )
    ()
  )

  (:operator (!!#{Dummy::VISIT}_pickup_1 ?a)
    (
      (not (visited_pickup_1 ?a))
    )
    ()
    (
      (visited_pickup_1 ?a)
    )
  )

  (:operator (!!un#{Dummy::VISIT}_pickup_1 ?a)
    ()
    (
      (visited_pickup_1 ?a)
    )
    ()
  )

  (:operator (!!#{Dummy::VISIT}_drop_1 ?a)
    (
      (not (visited_drop_1 ?a))
    )
    ()
    (
      (visited_drop_1 ?a)
    )
  )

  (:operator (!!un#{Dummy::VISIT}_drop_1 ?a)
    ()
    (
      (visited_drop_1 ?a)
    )
    ()
  )

  (:operator (!!goal)
    (
      (have banjo)
    )
    ()
    ()
  )

  ;------------------------------
  ; Methods
  ;------------------------------

  (:method (perform_goal_have_banjo )
    finish_perform_goal_have_banjo
    (
      (have banjo)
    )
    ()
  )

  (:method (perform_goal_have_banjo )
    try_pickup_to_perform_goal_have_banjo1
    (
      (not (have ?a))
    )
    (
      (!!#{Dummy::VISIT}_pickup_1 ?a)
      (!pickup ?a)
      (perform_goal_have_banjo)
      (!!un#{Dummy::VISIT}_pickup_1 ?a)
    )
  )

  (:method (perform_goal_have_banjo )
    try_drop_to_perform_goal_have_banjo1
    (
      (have ?a)
    )
    (
      (!!#{Dummy::VISIT}_drop_1 ?a)
      (!drop ?a)
      (perform_goal_have_banjo)
      (!!un#{Dummy::VISIT}_drop_1 ?a)
    )
  )
))",
      # Problem
'; Generated by Hype
(defproblem pb1 basic

  ;------------------------------
  ; Start
  ;------------------------------

  ()

  ;------------------------------
  ; Tasks
  ;------------------------------

  (:unordered
    (perform_goal_have_banjo)
    (!!goal)
  )
)'
    )
  end

  def test_basic_pb1_jshop_parsing_compile_to_markdown
    compiler_tests(
      # Files
      'examples/basic/basic.jshop',
      'examples/basic/pb1.jshop',
      # Extensions and output
      [], 'md',
      # Domain
'# Basic
## Predicates
- **have**: fluent

## Operators
Pickup | ?a
--- | ---
***Preconditions*** | ***Effects***
**not** (have ?a) | (have ?a)

Drop | ?a
--- | ---
***Preconditions*** | ***Effects***
(have ?a) | **not** (have ?a)

## Methods
Swap | ?x ?y ||
--- | --- | ---
***Label*** | ***Preconditions*** | ***Subtasks***
case_0 ||
|| (have ?x) | drop ?x
|| **not** (have ?y) | pickup ?y
case_1 ||
|| (have ?y) | drop ?y
|| **not** (have ?x) | pickup ?x',
      # Problem
'# Pb1 of Basic
## Initial state
- (have kiwi)

## Tasks
**ordered**
- (swap banjo kiwi)'
    )
  end

  def test_basic_pb1_jshop_parsing_compile_to_dot
    compiler_tests(
      # Files
      'examples/basic/basic.jshop',
      'examples/basic/pb1.jshop',
      # Extensions and output
      [], 'dot',
      # Domain
'// Generated by Hype
digraph "basic" {
  nodesep=1
  ranksep=1
  // Operators
  "pickup" [
    shape=record
    label="{{pickup|?a}|{not (have ?a)\l|(have ?a)\l}}"
  ]
  "drop" [
    shape=record
    label="{{drop|?a}|{(have ?a)\l|not (have ?a)\l}}"
  ]
  // Methods
  "swap" [
    shape=Mrecord
    style=bold
    label="{{swap|?x ?y}|{<n0>swap_case_0|<n1>swap_case_1}}"
  ]
  "label_swap_case_0" [
    shape=Mrecord
    label="{{swap_case_0|}|(have ?x)\lnot (have ?y)\l|<n0>drop ?x|<n1>pickup ?y}"
  ]
  "swap":n0 -> "label_swap_case_0" [style=dotted]
  "label_swap_case_0":n0 -> "drop"
  "label_swap_case_0":n1 -> "pickup"
  "label_swap_case_1" [
    shape=Mrecord
    label="{{swap_case_1|}|(have ?y)\lnot (have ?x)\l|<n0>drop ?y|<n1>pickup ?x}"
  ]
  "swap":n1 -> "label_swap_case_1" [style=dotted]
  "label_swap_case_1":n0 -> "drop"
  "label_swap_case_1":n1 -> "pickup"
}',
      # Problem
      nil
    )
  end

  def test_ruby
    ['jshop', 'hddl'].each {|type|
      interpreted_execution_tests(
        "examples/basic/basic.#{type}",
        "examples/basic/pb1.#{type}",
        "0: drop(kiwi)\n1: pickup(banjo)\n"
      )
    }
  end

  def test_gcc
    ['jshop', 'hddl'].each {|type|
      native_execution_tests(
        "examples/basic/basic.#{type}",
        "examples/basic/pb1.#{type}",
        'g++ -O3 -march=native -flto',
        "Planning\ndrop kiwi\npickup banjo\n"
      )
    }
  end if system('g++ -v')

  def test_clang
    ['jshop', 'hddl'].each {|type|
      native_execution_tests(
        "examples/basic/basic.#{type}",
        "examples/basic/pb1.#{type}",
        'clang++ -O3 -march=native -flto',
        "Planning\ndrop kiwi\npickup banjo\n"
      )
    }
  end if system('clang++ -v')
end