require './tests/hypest'

class Simple < Test::Unit::TestCase
  include Hypest

  PICKUP = ['pickup', ['?a'],
    # Preconditions
    [],
    [['have', '?a']],
    # Effects
    [['have', '?a']],
    []
  ]

  DROP = ['drop', ['?a'],
    # Preconditions
    [['have', '?a']],
    [],
    # Effects
    [],
    [['have', '?a']]
  ]

  def test_basic_pb1_jshop_parsing
    parser_tests(
      # Files
      'examples/basic/basic.jshop',
      'examples/basic/pb1.jshop',
      # Parser and extensions
      JSHOP_Parser, [],
      # Attributes
      :domain_name => 'basic',
      :problem_name => 'pb1',
      :operators => [PICKUP, DROP],
      :methods => [
        ['swap', ['?x', '?y'],
          ['case_0', [],
            # Preconditions
            [['have', '?x']],
            [['have', '?y']],
            # Subtasks
            [['drop', '?x'], ['pickup', '?y']]
          ],
          ['case_1', [],
            # Preconditions
            [['have', '?y']],
            [['have', '?x']],
            # Subtasks
            [['drop', '?y'], ['pickup', '?x']]
          ]
        ]
      ],
      :predicates => {'have' => true},
      :state => {'have' => [['kiwi']]},
      :tasks => [true, ['swap', 'banjo', 'kiwi']],
      :goal_pos => [],
      :goal_not => []
    )
  end

  def test_basic_pb1_pddl_parsing
    parser_tests(
      # Files
      'examples/basic/basic.pddl',
      'examples/basic/pb1.pddl',
      # Parser and extensions
      PDDL_Parser, [],
      # Attributes
      :domain_name => 'basic',
      :problem_name => 'pb1',
      :operators => [PICKUP, DROP],
      :methods => [],
      :predicates => {'have' => true},
      :state => {},
      :tasks => [],
      :goal_pos => [['have', 'banjo']],
      :goal_not => [],
      :objects => ['kiwi', 'banjo'],
      :requirements => [':strips', ':negative-preconditions']
    )
  end

  def test_basic_pb1_jshop_parsing_compile_to_pddl
    compiler_tests(
      # Files
      'examples/basic/basic.jshop',
      'examples/basic/pb1.jshop',
      # Parser, extensions and output
      JSHOP_Parser, [], 'pddl',
      # Domain
'; Generated by Hype
(define (domain basic)
  (:requirements :strips :negative-preconditions)

  (:predicates
    (have ?a)
  )

  (:action pickup
    :parameters (?a)
    :precondition (and
      (not (have ?a))
    )
    :effect (and
      (have ?a)
    )
  )

  (:action drop
    :parameters (?a)
    :precondition (and
      (have ?a)
    )
    :effect (and
      (not (have ?a))
    )
  )
)',
      # Problem
'; Generated by Hype
(define (problem pb1)
  (:domain basic)
  (:objects
    kiwi banjo
  )
  (:init
    (have kiwi)
  )
  (:goal (and
  ))
)'
    )
  end

  def test_basic_pb1_pddl_parsing_with_patterns
    parser_tests(
      # Files
      'examples/basic/basic.pddl',
      'examples/basic/pb3.pddl',
      # Parser and extensions
      PDDL_Parser, ['patterns'],
      # Attributes
      :domain_name => 'basic',
      :problem_name => 'pb3',
      :operators => [PICKUP, DROP],
      :methods => [],
      :predicates => {'have' => true},
      :state => {'have' => [['kiwi']]},
      :tasks => [false, ['pickup', 'banjo'], ['drop', 'kiwi']],
      :goal_pos => [['have', 'banjo']],
      :goal_not => [['have', 'kiwi']],
      :objects => ['kiwi', 'banjo'],
      :requirements => [':strips', ':negative-preconditions']
    )
  end

  def test_basic_pb1_jshop_parsing_with_macro
    parser_tests(
      # Files
      'examples/basic/basic.jshop',
      'examples/basic/pb1.jshop',
      # Parser and extensions
      JSHOP_Parser, ['macro'],
      # Attributes
      :domain_name => 'basic',
      :problem_name => 'pb1',
      :operators => [
        PICKUP,
        DROP,
        ['drop_dup', ['?a'], [], [], [], []],
        ['pickup_dup', ['?a'], [], [], [], []],
        ['invisible_drop_and_pickup', ['?x', '?y'],
          # Preconditions
          [['have', '?x']],
          [['have', '?y']],
          # Effects
          [['have', '?y']],
          [['have', '?x']]
        ]
      ],
      :methods => [
        ['swap', ['?x', '?y'],
          ['case_0', [],
            # Preconditions
            [['have', '?x']],
            [['have', '?y']],
            # Subtasks
            [['invisible_drop_and_pickup', '?x', '?y'], ['drop_dup', '?x'], ['pickup_dup', '?y']]
          ],
          ['case_1', [],
            # Preconditions
            [['have', '?y']],
            [['have', '?x']],
            # Subtasks
            [['invisible_drop_and_pickup', '?y', '?x'], ['drop_dup', '?y'], ['pickup_dup', '?x']]
          ]
        ]
      ],
      :predicates => {'have' => true},
      :state => {'have' => [['kiwi']]},
      :tasks => [true, ['swap', 'banjo', 'kiwi']],
      :goal_pos => [],
      :goal_not => []
    )
  end

  def test_basic_pb1_pddl_parsing_with_dummy_compile_to_jshop
    compiler_tests(
      # Files
      'examples/basic/basic.pddl',
      'examples/basic/pb1.pddl',
      # Parser, extensions and output
      PDDL_Parser, ['dummy'], 'jshop',
      # Domain
'; Generated by Hype
(defdomain basic (

  ;------------------------------
  ; Operators
  ;------------------------------

  (:operator (!pickup ?a)
    (
      (not (have ?a))
    )
    nil
    (
      (have ?a)
    )
  )

  (:operator (!drop ?a)
    (
      (have ?a)
    )
    (
      (have ?a)
    )
    nil
  )

  (:operator (!!visit_pickup_1 ?a)
    (
      (not (visited_pickup_1 ?a))
    )
    nil
    (
      (visited_pickup_1 ?a)
    )
  )

  (:operator (!!unvisit_pickup_1 ?a)
    nil
    (
      (visited_pickup_1 ?a)
    )
    nil
  )

  (:operator (!!visit_drop_1 ?a)
    (
      (not (visited_drop_1 ?a))
    )
    nil
    (
      (visited_drop_1 ?a)
    )
  )

  (:operator (!!unvisit_drop_1 ?a)
    nil
    (
      (visited_drop_1 ?a)
    )
    nil
  )

  ;------------------------------
  ; Methods
  ;------------------------------

  (:method (perform_goal_have_banjo )
    finish_perform_goal_have_banjo
    (
      (have banjo)
    )
    nil
  )

  (:method (perform_goal_have_banjo )
    try_pickup_to_perform_goal_have_banjo1
    (
      (not (have ?a))
    )
    (
      (!!visit_pickup_1 ?a)
      (!pickup ?a)
      (perform_goal_have_banjo)
      (!!unvisit_pickup_1 ?a)
    )
  )

  (:method (perform_goal_have_banjo )
    try_drop_to_perform_goal_have_banjo1
    (
      (have ?a)
    )
    (
      (!!visit_drop_1 ?a)
      (!drop ?a)
      (perform_goal_have_banjo)
      (!!unvisit_drop_1 ?a)
    )
  )
))',
      # Problem
'; Generated by Hype
(defproblem pb1 basic

  ;------------------------------
  ; Start
  ;------------------------------

  nil

  ;------------------------------
  ; Tasks
  ;------------------------------

  (:unordered
    (perform_goal_have_banjo)
  )
)'
    )
  end

  def test_basic_pb1_jshop_parsing_compile_to_markdown
    compiler_tests(
      # Files
      'examples/basic/basic.jshop',
      'examples/basic/pb1.jshop',
      # Parser, extensions and output
      JSHOP_Parser, [], 'md',
      # Domain
'# Basic
## Predicates
- **have**: fluent

## Operators
Pickup | ?a
--- | ---
***Preconditions*** | ***Effects***
**not** (have ?a) | (have ?a)

Drop | ?a
--- | ---
***Preconditions*** | ***Effects***
(have ?a) | **not** (have ?a)

## Methods
Swap | ?x ?y ||
--- | --- | ---
***Label*** | ***Preconditions*** | ***Subtasks***
case_0 ||
|| (have ?x) | drop ?x
|| **not** (have ?y) | pickup ?y
case_1 ||
|| (have ?y) | drop ?y
|| **not** (have ?x) | pickup ?x',
      # Problem
'# Pb1 of Basic
## Initial state
- (have kiwi)

## Tasks
**ordered**
- (swap banjo kiwi)'
    )
  end

  def test_basic_pb1_jshop_parsing_compile_to_dot
    compiler_tests(
      # Files
      'examples/basic/basic.jshop',
      'examples/basic/pb1.jshop',
      # Parser, extensions and output
      JSHOP_Parser, [], 'dot',
      # Domain
'// Generated by Hype
digraph "basic" {
  nodesep=1.0
  ranksep=1.0
  // Operators
  "pickup" [
    shape=record
    label="{{pickup|?a}|{not (have ?a)\l|(have ?a)\l}}"
  ]
  "drop" [
    shape=record
    label="{{drop|?a}|{(have ?a)\l|not (have ?a)\l}}"
  ]
  // Methods
  "swap" [
    shape=Mrecord
    style=bold
    label="{{swap|?x ?y}|{<n0>swap_case_0|<n1>swap_case_1}}"
  ]
  "label_swap_case_0" [
    shape=Mrecord
    label="{{swap_case_0|}|(have ?x)\lnot (have ?y)\l|<n0>drop ?x|<n1>pickup ?y}"
  ]
  "swap":n0 -> "label_swap_case_0" [style=dotted]
  "label_swap_case_0":n0 -> "drop"
  "label_swap_case_0":n1 -> "pickup"
  "label_swap_case_1" [
    shape=Mrecord
    label="{{swap_case_1|}|(have ?y)\lnot (have ?x)\l|<n0>drop ?y|<n1>pickup ?x}"
  ]
  "swap":n1 -> "label_swap_case_1" [style=dotted]
  "label_swap_case_1":n0 -> "drop"
  "label_swap_case_1":n1 -> "pickup"
}',
      # Problem
      nil
    )
  end
end